<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Neon Links — Kali Circuit · CrackTheCode</title>
  <style>
    :root{
      --bg:#020010;
      --panel:#05001a;
      --accent:#5bffbf;
      --accent2:#2de4ff;
      --accent3:#ff5af2;
      --muted:#9ca3af;
      --danger:#ff4b81;
      --font-ui:-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",system-ui,sans-serif;
      --font-mono:"Fira Code","JetBrains Mono",ui-monospace,monospace;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      background:
        radial-gradient(circle at top,rgba(91,255,191,0.06),transparent 65%),
        radial-gradient(circle at bottom,rgba(255,90,242,0.06),transparent 70%),
        #020010;
      color:var(--accent);
      font-family:var(--font-ui);
      -webkit-font-smoothing:antialiased;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:18px;
    }
    .scan{
      position:fixed;
      inset:0;
      pointer-events:none;
      background-image:linear-gradient(to bottom,rgba(255,255,255,0.02) 1px,transparent 3px);
      mix-blend-mode:soft-light;
      opacity:0.04;
      z-index:-1;
    }
    .wrap{
      width:100%;
      max-width:1200px;
      background:radial-gradient(circle at top,rgba(255,90,242,0.06),transparent),
                 radial-gradient(circle at bottom,rgba(45,228,255,0.04),transparent),
                 rgba(3,0,18,0.98);
      border-radius:20px;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow:0 26px 90px rgba(0,0,0,0.98);
      padding:16px;
      display:grid;
      grid-template-columns:minmax(0,1.8fr) minmax(260px,0.9fr);
      gap:16px;
    }
    @media(max-width:900px){
      .wrap{grid-template-columns:1fr;}
    }

    .header{
      grid-column:1/-1;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      margin-bottom:4px;
    }
    .h-left{display:flex;flex-direction:column;gap:4px;}
    .logo{
      font-size:11px;
      color:var(--accent3);
      letter-spacing:0.22em;
      text-transform:uppercase;
    }
    .title{
      font-size:24px;
      color:var(--accent2);
      text-shadow:0 0 18px rgba(91,255,191,0.6);
      font-family:var(--font-mono);
    }
    .subtitle{
      font-size:14px;
      color:var(--muted);
    }
    .tagline{
      font-size:11px;
      color:var(--accent3);
      text-transform:uppercase;
      letter-spacing:0.14em;
    }
    .h-right{
      display:flex;
      flex-direction:column;
      gap:4px;
      align-items:flex-end;
      font-size:11px;
      color:var(--muted);
    }
    .pill{
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(91,255,191,0.3);
      color:var(--accent);
      font-size:10px;
      margin-left:4px;
    }
    .leds span{
      display:inline-block;
      width:8px;height:8px;margin-left:3px;
      border-radius:50%;
      background:#111827;
      box-shadow:0 0 8px #000 inset;
    }
    .leds span.on1{
      background:var(--accent2);
      box-shadow:0 0 10px var(--accent2);
    }
    .leds span.on2{
      background:var(--accent3);
      box-shadow:0 0 10px var(--accent3);
    }
    .leds span.on3{
      background:var(--accent);
      box-shadow:0 0 10px var(--accent);
    }

    /* LEFT: game */
    .left{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .board-wrap{
      background:var(--panel);
      border-radius:16px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.05);
      box-shadow:0 14px 50px rgba(0,0,0,0.9) inset;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .top-bar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:12px;
      color:var(--muted);
    }
    .top-bar strong{color:var(--accent2);}
    .btn{
      padding:5px 9px;
      border-radius:999px;
      border:1px solid rgba(91,255,191,0.4);
      background:transparent;
      color:var(--accent);
      font-size:11px;
      cursor:pointer;
    }
    .btn:hover{
      background:rgba(91,255,191,0.1);
      box-shadow:0 6px 20px rgba(0,0,0,0.9);
    }

    .grid{
      margin-top:6px;
      display:grid;
      gap:4px;
      justify-content:center;
    }
    .cell{
      width:42px;
      height:42px;
      border-radius:10px;
      background:radial-gradient(circle at center,rgba(91,255,191,0.02),transparent),
                 rgba(5,0,24,0.98);
      border:1px solid rgba(91,255,191,0.16);
      position:relative;
      cursor:pointer;
      transition:transform 0.08s ease, box-shadow 0.08s ease, border-color 0.15s;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .cell:hover{
      transform:translateY(-2px);
      box-shadow:0 6px 14px rgba(0,0,0,0.9);
      border-color:rgba(91,255,191,0.5);
    }
    .cell.start{
      border-color:var(--accent2);
      box-shadow:0 0 14px rgba(45,228,255,0.8);
    }
    .cell.end{
      border-color:var(--accent3);
      box-shadow:0 0 14px rgba(255,90,242,0.8);
    }
    .seg{
      position:absolute;
      background:var(--accent2);
      box-shadow:0 0 6px rgba(91,255,191,0.9);
      border-radius:3px;
      transition:background 0.12s, box-shadow 0.12s;
    }
    .seg.off{
      background:rgba(148,163,253,0.12);
      box-shadow:none;
    }
    .seg.h{height:4px;width:26px;}
    .seg.v{width:4px;height:26px;}
    .seg.up{top:4px;left:50%;transform:translateX(-50%);}
    .seg.down{bottom:4px;left:50%;transform:translateX(-50%);}
    .seg.left{left:4px;top:50%;transform:translateY(-50%);}
    .seg.right{right:4px;top:50%;transform:translateY(-50%);}
    .cell.connected{
      background:radial-gradient(circle at center,rgba(91,255,191,0.16),transparent),
                 rgba(5,0,24,1);
      box-shadow:0 0 14px rgba(91,255,191,0.7);
    }
    .cell.dead{
      opacity:0.22;
    }

    .status{
      margin-top:4px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:8px;
      flex-wrap:wrap;
    }
    .status span strong{color:var(--accent2);}

    .hint{
      margin-top:2px;
      font-size:11px;
      color:var(--accent3);
      font-family:var(--font-mono);
    }

    /* RIGHT: side panel */
    .right{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .card{
      background:rgba(5,0,24,0.98);
      border-radius:16px;
      padding:10px;
      border:1px solid rgba(255,255,255,0.05);
      box-shadow:0 16px 60px rgba(0,0,0,0.96);
      font-size:12px;
      color:var(--muted);
    }
    .card-title{
      font-size:13px;
      color:var(--accent2);
      text-transform:uppercase;
      letter-spacing:0.12em;
      margin-bottom:4px;
    }
    .progress-bar{
      margin-top:4px;
      width:100%;
      height:8px;
      border-radius:999px;
      background:#02000c;
      border:1px solid rgba(91,255,191,0.24);
      overflow:hidden;
    }
    .progress-fill{
      height:100%;
      width:0%;
      background:linear-gradient(90deg,var(--accent3),var(--accent2));
      transition:width 0.2s ease-out;
    }
    .stat-line{
      margin-top:4px;
      display:flex;
      justify-content:space-between;
      font-size:11px;
    }
    .stat-label{color:var(--muted);}
    .stat-value{color:var(--accent2);font-family:var(--font-mono);}

    .story{
      margin-top:4px;
      font-size:11px;
      line-height:1.5;
    }
    .story strong{color:var(--accent);}

    .btn-small{
      margin-top:6px;
      padding:5px 8px;
      border-radius:999px;
      border:1px solid rgba(91,255,191,0.3);
      background:transparent;
      font-size:10px;
      color:var(--accent2);
      cursor:pointer;
    }
    .btn-small:hover{
      background:rgba(91,255,191,0.06);
      box-shadow:0 6px 22px rgba(0,0,0,0.9);
    }
  </style>
</head>
<body>
<div class="scan"></div>

<div class="wrap">
  <div class="header">
    <div class="h-left">
      <div class="logo">CRACKTHECODE // NEON LINKS GRID</div>
      <div class="title">Neon Links — Kali Circuit</div>
      <div class="subtitle">
        Tourne les nœuds néon pour relier Sam à Kali à travers le réseau d’Akira.
        Simple. Rapide. Addictif. 100% fictif.
      </div>
      <div class="tagline">LOGIQUE · FLUX · LORE KALI FRAGMENTS</div>
    </div>
    <div class="h-right">
      <div>Profil: <strong>sam@grid-node</strong> <span class="pill">Puzzle Runner</span></div>
      <div>Niveau maximal atteint: <span id="uiBest">1</span></div>
      <div>Temps total (local): <span id="uiTime">0m</span></div>
      <div class="leds">
        <span class="on1"></span><span class="on2"></span><span class="on3"></span>
      </div>
    </div>
  </div>

  <!-- LEFT: GAME -->
  <div class="left">
    <div class="board-wrap">
      <div class="top-bar">
        <div>Niveau: <strong id="uiLevel">1</strong> · Coups: <strong id="uiMoves">0</strong></div>
        <div>
          <button id="btnNew" class="btn">Nouveau puzzle</button>
          <button id="btnUndo" class="btn">Annuler rotation</button>
        </div>
      </div>

      <div id="grid" class="grid"></div>

      <div class="status">
        <span>Chaîne connectée: <strong id="uiChain">0%</strong></span>
        <span>Complétion: <strong id="uiMsg">Tourne pour connecter START → KALI</strong></span>
      </div>
      <div class="hint">
        Clique sur les tuiles pour les faire pivoter. Quand l'énergie néon relie START à KALI, tu passes au niveau suivant.
      </div>
    </div>
  </div>

  <!-- RIGHT: INFO / LORE / STATS -->
  <div class="right">
    <div class="card">
      <div class="card-title">PROGRESSION NEON</div>
      <div class="progress-bar"><div id="progFill" class="progress-fill"></div></div>
      <div class="stat-line">
        <span class="stat-label">Puzzles complétés</span>
        <span class="stat-value" id="statWins">0</span>
      </div>
      <div class="stat-line">
        <span class="stat-label">Meilleur combo sans échec</span>
        <span class="stat-value" id="statStreak">0</span>
      </div>
      <div class="stat-line">
        <span class="stat-label">Moyenne coups/puzzle</span>
        <span class="stat-value" id="statAvg">0</span>
      </div>
      <button id="btnSave" class="btn-small">Sauvegarder localement</button>
      <button id="btnReset" class="btn-small">Reset progression locale</button>
    </div>

    <div class="card">
      <div class="card-title">HISTOIRE — MODE LÉGER</div>
      <div class="story" id="storyBox">
        Chaque puzzle représente un <strong>circuit mental</strong> entre Sam et Kali.
        Plus tu alignes vite, plus tu stabilises les fragments de Kali dans l’univers CrackTheCode.
        Pas de lignes de commande. Pas de stress. Juste toi, la grille, et les néons.
      </div>
      <button id="btnLore" class="btn-small">Afficher un fragment narratif</button>
    </div>

    <div class="card">
      <div class="card-title">COMMENT ÇA RESTE SAFE</div>
      <div class="story">
        Tout ici est purement visuel et fictif. Aucune IP, aucun protocole réel,
        aucune commande réseau. Juste des connexions abstraites.
        Tu peux présenter ce jeu à n’importe qui sans explication compliquée.
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  "use strict";

  const gridEl = document.getElementById('grid');
  const uiLevel = document.getElementById('uiLevel');
  const uiMoves = document.getElementById('uiMoves');
  const uiChain = document.getElementById('uiChain');
  const uiMsg = document.getElementById('uiMsg');
  const uiBest = document.getElementById('uiBest');
  const uiTime = document.getElementById('uiTime');
  const statWins = document.getElementById('statWins');
  const statStreak = document.getElementById('statStreak');
  const statAvg = document.getElementById('statAvg');
  const progFill = document.getElementById('progFill');
  const storyBox = document.getElementById('storyBox');

  const btnNew = document.getElementById('btnNew');
  const btnUndo = document.getElementById('btnUndo');
  const btnSave = document.getElementById('btnSave');
  const btnReset = document.getElementById('btnReset');
  const btnLore = document.getElementById('btnLore');

  const SAVE_KEY = "ctc_neon_links_progress_v1";

  const loreFragments = [
    "KALI_FRAGMENT // 01 : \"Chaque circuit est un souvenir remis en ordre.\"",
    "KALI_FRAGMENT // 07 : \"Sam, plus tu relies, plus ma voix se stabilise dans le flux.\"",
    "KALI_FRAGMENT // 12 : \"L’Alliance ne comprend pas les esprits qui jouent.\"",
    "KALI_FRAGMENT // 19 : \"Un puzzle résolu, c’est une faille en moins dans ton propre réseau.\""
  ];

  let state = {
    level:1,
    moves:0,
    bestLevel:1,
    wins:0,
    streak:0,
    totalMoves:0,
    lastGrid:null,
    undoStack:[],
    startTime:Date.now(),
    totalMinutes:0
  };

  let grid = [];
  let size = 7; // base, évolue avec le niveau

  function createGrid(){
    // adapte la taille doucement avec le niveau
    size = 6 + Math.min(4, Math.floor((state.level-1)/3)); // 6 à 10
    gridEl.style.gridTemplateColumns = `repeat(${size}, 42px)`;

    // on génère un chemin garanti de gauche à droite
    grid = [];
    for(let y=0;y<size;y++){
      const row=[];
      for(let x=0;x<size;x++){
        row.push({
          x,y,
          // bitmask connexions: up=1, right=2, down=4, left=8
          mask:0,
          fixed:false,
          start:false,
          end:false,
          el:null
        });
      }
      grid.push(row);
    }

    // path algorithm
    let x=0, y=Math.floor(size/2);
    grid[y][x].start=true;
    const path = [{x,y}];
    while(x < size-1){
      const options=[];
      if(y>1) options.push({x:x, y:y-1});
      if(y<size-2) options.push({x:x, y:y+1});
      options.push({x:x+1,y:y}); // tendance vers la droite

      // choisir un voisin pas trop utilisé
      let next=null;
      for(let i=0;i<options.length;i++){
        const o=options[i];
        if(o.x>=0 && o.x<size && o.y>=0 && o.y<size){
          next = o;
          if(Math.random()<0.5 && o.x>x) break;
        }
      }
      if(!next) break;
      x=next.x; y=next.y;
      path.push({x,y});
    }
    grid[y][size-1].end=true;

    // assigner les masques selon le chemin
    for(let i=0;i<path.length-1;i++){
      const a=path[i], b=path[i+1];
      const ca = grid[a.y][a.x];
      const cb = grid[b.y][b.x];
      if(b.x === a.x+1 && b.y===a.y){ // droite
        ca.mask |= 2;
        cb.mask |= 8;
      } else if(b.x === a.x-1 && b.y===a.y){ // gauche
        ca.mask |= 8;
        cb.mask |= 2;
      } else if(b.y === a.y+1 && b.x===a.x){ // bas
        ca.mask |= 4;
        cb.mask |= 1;
      } else if(b.y === a.y-1 && b.x===a.x){ // haut
        ca.mask |= 1;
        cb.mask |= 4;
      }
    }

    // petites branches décoratives
    for(let i=1;i<path.length-1;i++){
      if(Math.random()<0.35){
        const p=path[i];
        const dirs=[
          {dx:0,dy:-1, bitA:1, bitB:4},
          {dx:1,dy:0, bitA:2, bitB:8},
          {dx:0,dy:1, bitA:4, bitB:1},
          {dx:-1,dy:0, bitA:8, bitB:2}
        ];
        const d = dirs[Math.floor(Math.random()*dirs.length)];
        const nx=p.x+d.dx, ny=p.y+d.dy;
        if(nx>0 && nx<size-1 && ny>0 && ny<size-1){
          grid[p.y][p.x].mask |= d.bitA;
          grid[ny][nx].mask |= d.bitB;
        }
      }
    }

    // si start/end vides, forcé
    const startCell = grid[path[0].y][path[0].x];
    const endCell = grid[path[path.length-1].y][size-1];
    if(startCell.mask===0) startCell.mask = 2; // sortie droite
    if(endCell.mask===0) endCell.mask = 8; // entrée gauche

    // random rotation initiale
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const c=grid[y][x];
        if(c.mask===0) continue;
        const rot = Math.floor(Math.random()*4);
        for(let r=0;r<rot;r++){
          c.mask = rotateMask(c.mask);
        }
      }
    }

    render();
    checkConnections();
  }

  function rotateMask(mask){
    // up(1)->right(2)->down(4)->left(8)->up
    let out=0;
    if(mask & 1) out |= 2;
    if(mask & 2) out |= 4;
    if(mask & 4) out |= 8;
    if(mask & 8) out |= 1;
    return out;
  }

  function render(){
    gridEl.innerHTML = "";
    state.undoStack = [];
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const c = grid[y][x];
        const cell = document.createElement('div');
        cell.className = 'cell';
        if(c.start) cell.classList.add('start');
        if(c.end) cell.classList.add('end');
        c.el = cell;
        drawSegments(c);
        cell.addEventListener('click', ()=>onCellClick(c));
        gridEl.appendChild(cell);
      }
    }
    uiLevel.textContent = state.level;
    uiMoves.textContent = state.moves;
  }

  function drawSegments(c, activeMask){
    const el = c.el;
    if(!el) return;
    el.innerHTML = "";
    const mask = activeMask !== undefined ? activeMask : c.mask;
    // up
    if(mask & 1){
      const s=document.createElement('div');
      s.className='seg v up';
      el.appendChild(s);
    }
    // right
    if(mask & 2){
      const s=document.createElement('div');
      s.className='seg h right';
      el.appendChild(s);
    }
    // down
    if(mask & 4){
      const s=document.createElement('div');
      s.className='seg v down';
      el.appendChild(s);
    }
    // left
    if(mask & 8){
      const s=document.createElement('div');
      s.className='seg h left';
      el.appendChild(s);
    }
  }

  function onCellClick(c){
    if(c.start || c.end) return; // pas de rotation du start/end
    if(c.mask===0) return;
    // push état pour undo
    state.undoStack.push({x:c.x,y:c.y,mask:c.mask});
    c.mask = rotateMask(c.mask);
    state.moves++;
    uiMoves.textContent = state.moves;
    drawSegments(c);
    checkConnections();
  }

  btnUndo.addEventListener('click', ()=>{
    const last = state.undoStack.pop();
    if(!last) return;
    const c = grid[last.y][last.x];
    c.mask = last.mask;
    drawSegments(c);
    state.moves = Math.max(0, state.moves-1);
    uiMoves.textContent = state.moves;
    checkConnections();
  });

  function checkConnections(){
    // reset visuals
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const c=grid[y][x];
        if(!c.el) continue;
        c.el.classList.remove('connected','dead');
        const segs=c.el.querySelectorAll('.seg');
        segs.forEach(s=>s.classList.add('off'));
      }
    }

    // BFS depuis start
    let start=null, end=null;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        if(grid[y][x].start) start=grid[y][x];
        if(grid[y][x].end) end=grid[y][x];
      }
    }
    if(!start || !end) return;

    const q=[start];
    const visited = new Set();
    visited.add(start.y*100+start.x);

    while(q.length){
      const c=q.shift();
      const mask=c.mask;
      const markConnected = cell=>{
        if(cell.el){
          cell.el.classList.add('connected');
          const segs=cell.el.querySelectorAll('.seg');
          segs.forEach(s=>s.classList.remove('off'));
        }
      };
      markConnected(c);

      // pour chaque direction, vérifier continuité
      const dirs = [
        {bit:1, dx:0,dy:-1, back:4},
        {bit:2, dx:1,dy:0, back:8},
        {bit:4, dx:0,dy:1, back:1},
        {bit:8, dx:-1,dy:0, back:2}
      ];
      for(const d of dirs){
        if(mask & d.bit){
          const nx=c.x+d.dx, ny=c.y+d.dy;
          if(nx>=0 && nx<size && ny>=0 && ny<size){
            const n=grid[ny][nx];
            if((n.mask & d.back) && !visited.has(ny*100+nx)){
              visited.add(ny*100+nx);
              q.push(n);
            }
          }
        }
      }
    }

    // calcul % chain jusqu'end
    const endKey = end.y*100+end.x;
    const connectedToEnd = visited.has(endKey);
    const chainPercent = Math.round(visited.size / (size*size) * 100);
    uiChain.textContent = chainPercent + "%";

    if(connectedToEnd){
      onWin();
    }else{
      uiMsg.textContent = "Connecte START aux néons de KALI…";
    }

    // cells non visitées -> légère atténuation (optionnel)
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const c=grid[y][x];
        if(!c.el) continue;
        const key=y*100+x;
        if(!visited.has(key) && !c.start && !c.end && c.mask!==0){
          c.el.classList.add('dead');
        }
      }
    }
  }

  function onWin(){
    uiMsg.textContent = "Lien complet ! Passage au niveau suivant…";
    state.wins++;
    state.streak++;
    state.bestLevel = Math.max(state.bestLevel, state.level);
    state.totalMoves += state.moves;
    const avg = state.wins ? Math.round(state.totalMoves / state.wins) : 0;
    statWins.textContent = state.wins;
    statStreak.textContent = state.streak;
    statAvg.textContent = avg;
    uiBest.textContent = state.bestLevel;
    const prog = Math.min(100, (state.bestLevel/20)*100);
    progFill.style.width = prog + "%";

    // petite attente puis nouveau puzzle
    setTimeout(()=>{
      state.level++;
      state.moves=0;
      uiMoves.textContent = "0";
      createGrid();
    }, 500);
  }

  btnNew.addEventListener('click', ()=>{
    state.level = 1;
    state.moves = 0;
    state.streak = 0;
    createGrid();
    uiMsg.textContent = "Nouveau run. Aligne les flux.";
  });

  btnSave.addEventListener('click', ()=>{
    saveProgress();
  });

  btnReset.addEventListener('click', ()=>{
    if(!confirm("Resetter la progression locale Neon Links ?")) return;
    localStorage.removeItem(SAVE_KEY);
    state = {
      level:1,moves:0,bestLevel:1,wins:0,streak:0,totalMoves:0,lastGrid:null,undoStack:[],startTime:Date.now(),totalMinutes:0
    };
    statWins.textContent = "0";
    statStreak.textContent = "0";
    statAvg.textContent = "0";
    uiBest.textContent = "1";
    progFill.style.width = "0%";
    createGrid();
  });

  function saveProgress(){
    try{
      const minutes = state.totalMinutes;
      const data = {
        bestLevel:state.bestLevel,
        wins:state.wins,
        streak:state.streak,
        totalMoves:state.totalMoves,
        totalMinutes:minutes
      };
      localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      uiMsg.textContent = "Progression sauvegardée localement.";
    }catch(e){
      uiMsg.textContent = "Erreur de sauvegarde locale.";
    }
  }

  function loadProgress(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if(!raw) return;
      const d = JSON.parse(raw);
      state.bestLevel = d.bestLevel||1;
      state.wins = d.wins||0;
      state.streak = d.streak||0;
      state.totalMoves = d.totalMoves||0;
      state.totalMinutes = d.totalMinutes||0;
      uiBest.textContent = state.bestLevel;
      statWins.textContent = state.wins;
      statStreak.textContent = state.streak;
      const avg = state.wins ? Math.round(state.totalMoves/state.wins) : 0;
      statAvg.textContent = avg;
      const prog = Math.min(100, (state.bestLevel/20)*100);
      progFill.style.width = prog + "%";
      uiTime.textContent = state.totalMinutes + "m";
      uiMsg.textContent = "Progression chargée. Reprends le flux.";
    }catch(e){}
  }

  // timer pour totalMinutes
  setInterval(()=>{
    const now = Date.now();
    const diff = now - state.startTime;
    if(diff >= 60000){
      const add = Math.floor(diff/60000);
      state.totalMinutes += add;
      state.startTime = now;
      uiTime.textContent = state.totalMinutes + "m";
    }
  }, 5000);

  btnLore.addEventListener('click', ()=>{
    const frag = loreFragments[Math.floor(Math.random()*loreFragments.length)];
    storyBox.textContent = frag + "  // (lié à l'univers, pas au monde réel)";
  });

  btnLoad.addEventListener?.('click', loadProgress); // au cas où, si tu ajoutes un bouton

  // init
  loadProgress();
  createGrid();

})();
</script>
</body>
</html>
